#!/bin/bash
$tinyproxy_pid
# Verifica se o scrot est√° instalado
if ! command -v scrot &> /dev/null
then
    echo "scrot n√£o est√° instalado. Instalando..."
    sudo apt-get install scrot -y
fi

# Verifica se o zenity est√° instalado
if ! command -v zenity &> /dev/null
then
    echo "zenity n√£o est√° instalado. Instalando..."
    sudo apt-get install zenity -y
fi

# Verifica se o ffmpeg est√° instalado
if ! command -v ffmpeg &> /dev/null
then
    echo "ffmpeg n√£o est√° instalado. Instalando..."
    sudo apt-get install ffmpeg -y
fi

# Verifica se o ImageMagick est√° instalado
if ! command -v convert &> /dev/null
then
    echo "ImageMagick n√£o est√° instalado. Instalando..."
    sudo apt-get install imagemagick -y
fi

# Verifica se o exiftool est√° instalado
if ! command -v exiftool &> /dev/null
then
    echo "exiftool n√£o est√° instalado. Instalando..."
    sudo apt-get install exiftool -y
fi

# Verifica se o pandoc est√° instalado
if ! command -v pandoc &> /dev/null
then
    echo "pandoc n√£o est√° instalado. Instalando..."
    sudo apt-get install pandoc -y
fi

# Verifica se o slop est√° instalado
if ! command -v slop &> /dev/null
then
    echo "slop n√£o est√° instalado. Instalando..."
    sudo apt-get install slop -y
fi
# Verifica se o maim est√° instalado
if ! command -v maim &> /dev/null
then
    echo "maim n√£o est√° instalado. Instalando..."
    sudo apt-get install maim -y
fi
if ! command -v xclip &> /dev/null
then
    echo "xclip n√£o est√° instalado. Instalando..."
    sudo apt-get install xclip -y
fi
# Verifica se o Tinyproxy est√° instalado
if ! command -v tinyproxy &> /dev/null
then
    echo "Tinyproxy n√£o est√° instalado. Instalando..."
    sudo apt-get install tinyproxy -y
fi
# Fun√ß√£o para selecionar a pasta de trabalho
selecionar_pasta() {
    pasta=$(zenity --file-selection --directory --title="Selecione a pasta de trabalho")
    if [ -z "$pasta" ]; then
        zenity --error --text="Nenhuma pasta selecionada. Saindo..."
        exit 1
    fi
    echo "Pasta selecionada: $pasta"
    # Verifica se o arquivo oculto .odysseus_osint_report_session existe
    session_file="$pasta/.odysseus_osint_report_session"    
    # Verifica se a pasta est√° vazia ou cont√©m o arquivo de sess√£o
    if [ "$(ls -A "$pasta")" ] && [ ! -f "$session_file" ]; then
        zenity --error --text="A pasta deve estar vazia ou conter ou sess√£o do Odysseus Report. "
        exit 1
    fi
    #echo "Pasta selecionada: $pasta"

    if [ ! -f "$session_file" ]; then
        # Cria o arquivo se n√£o existir
        touch "$session_file"
        echo "opensession: F $(date)" >> "$session_file"
        # Verifica se o arquivo report_build.txt existe
        report_file="$pasta/report_build.txt"
        if [ ! -f "$report_file" ]; then
            touch "$report_file"
            echo "Arquivo report_build.txt criado."
        fi
    else
        # Verifica se o arquivo cont√©m a linha "closedsession"
        if grep -q "closedsession:" "$session_file"; then
            last_closed_session=$(grep "closedsession:" "$session_file" | tail -n 1 | cut -d ' ' -f 2-)
            zenity --info --text="Sess√£o anterior foi fechada em: $last_closed_session"
            #echo "opensession: F $(date)" >> "$session_file"
            #exit 1
    
        else
            echo "opensession: R $(date)" >> "$session_file" 
            last_session=$(grep "opensession:" "$session_file" | tail -n 1 | cut -d ' ' -f 3-)
            zenity --info --text="‚ö†Ô∏è √öltima sess√£o: $last_session\n\nüìÇ Pasta de trabalho: $pasta"
            #zenity --info --text=""
        fi
    fi
}


# Fun√ß√£o para obter informa√ß√µes do sistema
obter_info_sistema() {
    echo "Data e Hora: $(date)"
    echo "Host: $(hostname)"
    echo "Usu√°rio: $(whoami)"
    echo "IP: $(hostname -I | awk '{print $1}')"
}

# Fun√ß√£o para gravar log
gravar_log() {
    local acao=$1
    local arquivo=$2
    {
        obter_info_sistema
        echo "A√ß√£o: $acao"
        echo "Arquivo: $arquivo"
        echo "-------------------------"
    } >> "$pasta/odysseus_snap.log"
}
# Fun√ß√£o para capturar uma √°rea da tela
capturar_area() {
    if [ -z "$pasta" ]; then
        zenity --error --text="Nenhuma pasta selecionada. Selecione uma pasta primeiro."
        return
    fi

    zenity --info --text="Selecione uma √°rea da tela para capturar."
    
    # Define o nome do arquivo como screenshot_data_hora
    timestamp=$(date +"%Y%m%d_%H%M%S")
    screenshot_file="$pasta/screenshot_$timestamp.png"

    # Captura a √°rea selecionada e desenha uma linha vermelha de 3 pixels de largura ao redor da √°rea selecionada
     maim -s -u -b 3 -c 0.8,0,0,0.5 "$screenshot_file" 

    # Copia a imagem para a √°rea de transfer√™ncia
    xclip -selection clipboard -t image/png -i "$screenshot_file"
    
    # Obt√©m informa√ß√µes da janela selecionada
    window_info=$(xwininfo)
    window_id=$(echo "$window_info" | grep 'Window id:' | awk '{print $4}')
    window_name=$(xprop -id "$window_id" | grep 'WM_NAME(STRING)' | cut -d '"' -f 2)
    
    # Obt√©m a URL da aba ativa se for um navegador
    url=$(xdotool getactivewindow getwindowname | awk -F' - ' '{print $1}')
    
    # Exibe mensagem de confirma√ß√£o
    zenity --info --text="Captura de tela salva em $screenshot_file"
    
    # Abre a captura de tela com o visualizador de imagens padr√£o
    xdg-open "$screenshot_file"
    
    # Grava log da a√ß√£o
    {
        echo "Janela Selecionada: $window_name"
        echo "Informa√ß√µes da Janela:"
        echo "$window_info"
        echo "URL: $url"
    } >> "$pasta/odysseus_snap.log"
    gravar_log "Captura de Tela" "$screenshot_file \n $window_info \n JANELA: $url"
    echo "CAPTURA DE TELA: $screenshot_file" >> "$pasta/report_build.txt"
}

relatorio_final() {
    if [ -z "$pasta" ]; then
        zenity --error --text="Nenhuma pasta selecionada. Selecione uma pasta primeiro."
        return
    fi

    report_file="$pasta/report_build.txt"
    if [ ! -f "$report_file" ]; then
        zenity --error --text="Arquivo report_build.txt n√£o encontrado na pasta de trabalho."
        return
    fi

    pasta_saida=$(zenity --file-selection --directory --title="Selecione a pasta de sa√≠da do relat√≥rio final")
    if [ -z "$pasta_saida" ]; then
        zenity --error --text="Nenhuma pasta selecionada. Saindo..."
        return
    fi

    TEMP_FILE="$pasta/relatorio_final.md"
    OUTPUT_FILE_PDF="$pasta_saida/relatorio_final.pdf"

    # Cabe√ßalho do arquivo Markdown
    cat <<EOF > "$TEMP_FILE"
---
title: "Relat√≥rio Final"
author: "Odysseus SNAP"
date: "$(date)"
geometry: margin=1in
---

# Relat√≥rio Autom√°tico de Evid√™ncia(s) Digital(is)

## Informa√ß√µes do Sistema
\`\`\`
$(obter_info_sistema)
\`\`\`

## Introdu√ß√£o T√©cnica
Este relat√≥rio foi gerado automaticamente pelo Odysseus SNAP, uma ferramenta de coleta de evid√™ncias digitais para investiga√ß√µes forenses. O relat√≥rio cont√©m informa√ß√µes sobre arquivos, metadados e capturas de tela capturadas durante a investiga√ß√£o, al√©m de aplicar fun√ß√µes hash conhecidas para garantir a integridade dos dados.

## Fun√ß√µes Hash e Integridade
As fun√ß√µes hash s√£o sequ√™ncias alfanum√©ricas geradas por opera√ß√µes matem√°ticas e l√≥gicas, produzindo um c√≥digo de tamanho fixo que, em regra, √© √∫nico para cada arquivo. Qualquer m√≠nima altera√ß√£o no arquivo resulta em um hash completamente diferente, garantindo a detec√ß√£o de modifica√ß√µes.

## Lista de Arquivos
EOF
while IFS= read -r line || [[ -n "$line" ]]; do
    if [[ "$line" == URL:* ]]; then
        url="${line#URL: }"
        echo "### URL: [$url]($url)" >> "$TEMP_FILE"
    elif [[ "$line" == CAPTURA\ DE\ TELA:* ]]; then
        screenshot_file="${line#CAPTURA DE TELA: }"
        exif_info=$(exiftool "$screenshot_file")
        hash=$(sha256sum "$screenshot_file" | awk '{print $1}')
        echo "#### $(basename "$screenshot_file")" >> "$TEMP_FILE"
        if [[ "$screenshot_file" =~ \.mp4$ ]]; then
            mkdir -p "$pasta/thumbnails"
            thumbnail_file="$pasta/thumbnails/$(basename "${screenshot_file%.mp4}_thumbnail.png")"
            ffmpeg -i "$screenshot_file" -ss 00:00:01.000 -vframes 1 "$thumbnail_file"
            echo "| ![Imagem](file://$(realpath "$thumbnail_file")) |" >> "$TEMP_FILE"
            echo "|:--:|" >> "$TEMP_FILE"
            echo "{ width=50% }" >> "$TEMP_FILE"
            mkdir -p "$pasta_saida/videos"
            cp "$screenshot_file" "$pasta_saida/videos/"
            echo "[Clique aqui para acessar o arquivo](./videos/$(basename "$screenshot_file"))" >> "$TEMP_FILE"
        else
            echo "| ![Imagem](file://$(realpath "$screenshot_file")) |" >> "$TEMP_FILE"
            echo "|:--:|" >> "$TEMP_FILE"
            mkdir -p "$pasta_saida/imagens"
            cp "$screenshot_file" "$pasta_saida/imagens/"
            echo "[Clique aqui para acessar o arquivo](./imagens/$(basename "$screenshot_file"))" >> "$TEMP_FILE"
        fi
        echo "\`\`\`" >> "$TEMP_FILE"
        echo "| Campo | Valor |" >> "$TEMP_FILE"
        echo "|-------|-------|" >> "$TEMP_FILE"
        echo "$exif_info" | while IFS= read -r line; do
            field=$(echo "$line" | cut -d ':' -f 1)
            value=$(echo "$line" | cut -d ':' -f 2-)
            echo "| $field | $value |" >> "$TEMP_FILE"
        done
        echo "\`\`\`" >> "$TEMP_FILE"
        echo "**SHA256 Hash:** $hash" >> "$TEMP_FILE"
        echo "---" >> "$TEMP_FILE"
    fi
done < <(cat "$report_file"; echo)

    # Rodap√© do arquivo Markdown
    cat <<EOF >> "$TEMP_FILE"

## Logs de Navega√ß√£o
Os logs de navega√ß√£o s√£o registros detalhados das atividades realizadas por um usu√°rio em um navegador ou dispositivo. Eles incluem informa√ß√µes como URLs acessadas, hor√°rios de acesso, cookies, downloads e intera√ß√µes com p√°ginas web. Sua import√¢ncia para o OSINT pode ser resumida em:

- **Rastreamento de Atividades:** Permitem identificar quais sites foram visitados, o tempo gasto em cada p√°gina e as a√ß√µes realizadas, ajudando a tra√ßar um perfil de comportamento do usu√°rio.
- **Identifica√ß√£o de Padr√µes:** Atrav√©s da an√°lise de logs, √© poss√≠vel detectar padr√µes de navega√ß√£o, como hor√°rios de acesso frequentes ou prefer√™ncias de conte√∫do.
- **Investiga√ß√£o de Incidentes:** Em casos de cibercrimes, os logs podem fornecer evid√™ncias sobre atividades suspeitas, como tentativas de acesso a sites maliciosos ou compartilhamento de informa√ß√µes sens√≠veis.
- **Coleta de Metadados:** Informa√ß√µes como endere√ßos IP, geolocaliza√ß√£o e tipo de dispositivo podem ser extra√≠das dos logs, auxiliando na identifica√ß√£o de usu√°rios ou sistemas.

## Arquivos de Logs
| Arquivo | Hash SHA-256 |
|---------|--------------|
EOF

    for log_file in "$pasta/requests.txt" "$pasta/odysseus_snap.log"; do
        if [ -f "$log_file" ]; then
            hash=$(sha256sum "$log_file" | awk '{print $1}')
            echo "| $(basename "$log_file") | $hash |" >> "$TEMP_FILE"
        fi
    done

    cat <<EOF >> "$TEMP_FILE"

## Refer√™ncias T√©cnicas
1. **Vecchia, Evandro Dalla.** *Per√≠cia Digital. Da Investiga√ß√£o √† An√°lise Forense.* 2¬™ edi√ß√£o. Campinas: SP - Millennium Editora Ltda, 2019.
2. **Eleut√©rio, Pedro Monteiro da Silva e Machado, M√°rcio Pereira.** *Desvendando a Computa√ß√£o Forense.* 1¬™ Edi√ß√£o. S√£o Paulo: SP - Novatec Editora Ltda, 2011.
3. **Velho, Jesus Ant√¥nio.** *Tratado da Computa√ß√£o Forense.* 1¬™ Edi√ß√£o. Campinas: SP - Millennium Editora Ltda, 2016.
4. **STJ, AgRg no HC 828054/RN.** Julgado em 23/04/2024.

EOF

    # Converter o relat√≥rio para PDF usando pandoc
    pandoc "$TEMP_FILE" -o "$OUTPUT_FILE_PDF" --pdf-engine=xelatex

    # Remover o arquivo tempor√°rio
    mv "$TEMP_FILE" "$pasta/relatorio_final_$(date +"%Y%m%d_%H%M%S").md"

    # Informar ao usu√°rio que o relat√≥rio foi gerado
    zenity --info --text="Relat√≥rio final gerado em $OUTPUT_FILE_PDF"
     
    # Criar as pastas de sa√≠da
    mkdir -p "$pasta_saida/imagens"
    mkdir -p "$pasta_saida/videos"
    mkdir -p "$pasta_saida/logs"

    # Copiar arquivos para as respectivas pastas
    cp "$pasta"/*.png "$pasta_saida/imagens/"
    cp "$pasta"/*.mp4 "$pasta_saida/videos/"
    cp "$pasta/requests.txt" "$pasta_saida/logs/"
    cp "$pasta/odysseus_snap.log" "$pasta_saida/logs/"

    # Renomear a pasta de thumbs para thumbs_old
    if [ -d "$pasta/thumbnails" ]; then
        mv "$pasta/thumbnails" "$pasta/thumbnails_old"
    fi

    # Abrir o relat√≥rio PDF gerado com a aplica√ß√£o padr√£o
    xdg-open "$OUTPUT_FILE_PDF"
    gravar_log "Cria√ß√£o de Relat√≥rio Final" "$OUTPUT_FILE_PDF"
}
# Fun√ß√£o para gravar a tela
gravar_tela() {
    if [ -z "$pasta" ]; then
        zenity --error --text="Nenhuma pasta selecionada. Selecione uma pasta primeiro."
        return
    fi

    zenity --info --text="Selecione a √°rea da tela que deseja gravar."

    # Obt√©m a geometria da √°rea selecionada
    geometry=$(slop -f "%x %y %w %h" -b 5 -c 0.8,0,0,0.5 )
    read -r x y width height <<< "$geometry"

    # Obt√©m informa√ß√µes da janela selecionada
    window_info=$(xwininfo)
    window_id=$(echo "$window_info" | grep 'Window id:' | awk '{print $4}')
    window_name=$(xprop -id "$window_id" | grep 'WM_NAME(STRING)' | cut -d '"' -f 2)

    # Encontra o pr√≥ximo n√∫mero dispon√≠vel para o screencast
    for i in $(seq 1 10000); do
        if [ ! -f "$pasta/screencast_$i.mp4" ]; then
            # Inicia a grava√ß√£o em segundo plano
            ffmpeg -video_size "${width}x${height}" -framerate 25 -f x11grab -i :0.0+$x,$y \
                -vf "drawbox=x=0:y=0:w=${width}:h=${height}:color=red@1:t=3" \
                "$pasta/screencast_$i.mp4" &
            ffmpeg_pid=$!

            # Mostra uma splash screen enquanto grava
            (
                zenity --info --text="Gravando tela!" --title="Grava√ß√£o em andamento" --no-wrap &
                zenity_pid=$!
                wait $ffmpeg_pid
                kill $zenity_pid
            ) &

            # Cria um bot√£o flutuante para interromper a grava√ß√£o
            zenity --info --text="Clique em OK para parar a grava√ß√£o." --title="Parar Grava√ß√£o"
            
            # Interrompe a grava√ß√£o
            kill $ffmpeg_pid
            zenity --info --text="Grava√ß√£o de tela salva em $pasta/screencast_$i.mp4"
            
            # Grava log da a√ß√£o
            {
                echo "Janela Selecionada: $window_name"
                echo "Informa√ß√µes da Janela:"
                echo "$window_info"
            } >> "$pasta/odysseus_snap.log"
            gravar_log "Grava√ß√£o de Tela" "$pasta/screencast_$i.mp4 \n $window_info \n JANELA: $window_name"
            echo "CAPTURA DE TELA: $pasta/screencast_$i.mp4" >> "$pasta/report_build.txt"
            break
        fi
    done
}
# Fun√ß√£o para abrir a pasta de trabalho
abrir_pasta() {
    if [ -z "$pasta" ]; then
        zenity --error --text="Nenhuma pasta selecionada. Selecione uma pasta primeiro."
    else
        xdg-open "$pasta"
    fi
}


# Fun√ß√£o para interceptar endere√ßos
interceptar_enderecos() {
    if [ -z "$pasta" ]; then
        zenity --error --text="Nenhuma pasta selecionada. Selecione uma pasta primeiro."
        return
    fi

    output_log="$pasta/requests.txt"

    # Verifica se o mitmproxy est√° instalado
    if ! command -v mitmproxy &> /dev/null; then
        zenity --error --text="mitmproxy n√£o est√° instalado. Instale-o usando 'sudo apt-get install mitmproxy'."
        return
    fi

    # Cria o script de filtro Python dinamicamente com o caminho correto do arquivo de log
    filtro_py="$pasta/filter.py"
    cat <<EOF > "$filtro_py"
from mitmproxy import http
from datetime import datetime

def request(flow: http.HTTPFlow) -> None:
    # Verifica se √© uma requisi√ß√£o de clique em um link
    if (
        "Referer" in flow.request.headers  # Tem cabe√ßalho Referer (indicando que veio de uma p√°gina anterior)
        and flow.request.method == "GET"   # M√©todo GET
        and not flow.request.headers.get("Content-Type", "").startswith(("text/css", "image/", "application/javascript"))  # Exclui recursos secund√°rios
        and not any(ext in flow.request.pretty_url for ext in [".js", ".css", ".png", ".jpg", ".gif", ".ico", ".svg",".mp4"])  # Exclui recursos secund√°rios
    ):
        # Loga a requisi√ß√£o de clique em um link
        log_message = f"Data e Hora: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
        log_message += f"link: {flow.request.pretty_url}\n"
        log_message += f"Referer: {flow.request.headers['Referer']}\n"
        #log_message += f"Cabe√ßalho: {flow.request.headers}\n\n"
        
        # Escreve no arquivo request.txt
        with open("$output_log", "a") as file:
            file.write(log_message)
        
        # Exemplo de modifica√ß√£o da requisi√ß√£o
        flow.request.headers["X-Link-Click"] = "True"
EOF
    chmod +777 "$filtro_py"
    # Inicia o mitmproxy com o script de filtro
    xterm -e "mitmproxy -s \"$filtro_py\" --set output_log=\"$output_log\"; exec bash &"& 
    mitmproxy_pid=$!
    echo $mitmproxy_pid > /tmp/mitmproxy_pid
    #zenity --info --text="Intercepta√ß√£o de endere√ßos iniciada. PID: $mitmproxy_pid"
}
# Fun√ß√£o para parar a intercepta√ß√£o de endere√ßos
parar_interceptacao() {
    if [ -f /tmp/mitmproxy_pid ]; then
        mitmproxy_pid=$(cat /tmp/mitmproxy_pid)
        if [ -n "$mitmproxy_pid" ]; then
            kill $mitmproxy_pid
            rm /tmp/mitmproxy_pid
            #zenity --info --text="Intercepta√ß√£o parada. Arquivo salvo em $output_log"
        fi
    fi
# Fecha a inst√¢ncia aberta do Firefox
if pgrep firefox > /dev/null; then
    pkill firefox
    #zenity --info --text="Inst√¢ncia do Firefox fechada."
fi
if  pgrep tail > /dev/null; then
    pkill tail
    #zenity --info --text="Inst√¢ncia do Firefox fechada."
fi
if pgrep zenity > /dev/null; then
    pkill zenity
    echo
fi
      
}
# Fun√ß√£o para verificar se o caso j√° foi fechado
verificar_caso_fechado() {
    if grep -q "closedsession:" "$session_file"; then
        zenity --info --text="O caso j√° foi fechado."
        return 0
    else
        return 1
    fi
}

# Fun√ß√£o para monitorar requests.txt em uma thread separada
monitorar_requests() {
    if [ -z "$pasta" ]; then
        zenity --error --text="Nenhuma pasta selecionada. Selecione uma pasta primeiro."
        return
    fi

    tail -f "$pasta/requests.txt" | zenity --text-info --title="Monitorar requests.txt" --width=800 --height=600 &
    tail_pid=$!
}
abrir_url() {
    url=$(zenity --entry --title="Abrir URL" --text="Digite a URL que deseja abrir:")
    if [ -n "$url" ]; then
        firefox --new-tab "$url"
        echo "URL: $url" >> "$pasta/report_build.txt"
        zenity --info --text="URL aberta em uma nova aba do Firefox."
    else
        zenity --error --text="Nenhuma URL fornecida."
    fi
}
fechar_e_abrir_firefox() {
    # Verifica se h√° inst√¢ncias do Firefox em execu√ß√£o
    if ! verificar_caso_fechado; then
        
        if pgrep firefox > /dev/null; then
            # Fecha todas as inst√¢ncias do Firefox
            pkill firefox
            #zenity --info --text="Todas as inst√¢ncias do Firefox foram fechadas."
        fi

        # Abre uma nova sess√£o do Firefox sem abas abertas
        firefox --new-instance --no-remote about:blank &
        # Cria o arquivo requests.txt na pasta de trabalho e escreve a primeira linha
        echo "Relat√≥rio de Requisi√ß√£o" >> "$pasta/requests.txt"
        echo "" >> "$pasta/report_build.txt"
        #zenity --info --text="Nova sess√£o do Firefox iniciada."
    fi
}
closedsession() {
    if [ -z "$pasta" ]; then
        zenity --error --text="Nenhuma pasta selecionada. Selecione uma pasta primeiro."
        return
    fi
    session_file="$pasta/.odysseus_osint_report_session"
    if [ ! -f "$session_file" ]; then
        zenity --error --text="Arquivo de sess√£o n√£o encontrado."
        return
    fi
    if grep -q "closedsession:" "$session_file"; then
        zenity --info --text="Sess√£o j√° foi fechada."
    else
        echo "closedsession: $(date)" >> "$session_file"
        zenity --info --text="Sess√£o fechada com sucesso."
        parar_interceptacao; 
        
    fi
}
# Processos em segundo plano

# Configura o manipulador de sinal para encerrar o processo de monitoramento ao sair
trap "parar_interceptacao; [ -n \"$tail_pid\" ] && kill $tail_pid" EXIT
# Seleciona a pasta de trabalho
selecionar_pasta
# Inicia a intercepta√ß√£o de endere√ßos em uma thread
if ! verificar_caso_fechado; then
    interceptar_enderecos &
    # Inicia o monitoramento do arquivo requests.txt em uma thread
    fechar_e_abrir_firefox
fi


# Verifica se o caso j√° foi fechado antes de iniciar a interface gr√°fica
#if verificar_caso_fechado; then
    #exit 0
#fi

# Interface gr√°fica principal
while true; do
    acao=$(zenity --list --title="Odysseus OSINT Report" --column="A√ß√£o" \
         "üîó Registrar URL" \
        "üì∏ Capturar √Årea da Tela" \
        "üé• Gravar Tela" \
        "üìÇ Abrir Pasta de Trabalho" \
        "üìà Monitorar Requisi√ß√µes" \
        "üìÑ Criar Relat√≥rio em PDF" \
        "üö™ Sair" \
        "üîí Fechar Sess√£o"\
        --height=400 --width=500 --text="Selecione uma a√ß√£o:" --cancel-label="Sair" --hide-header)
    if [ $? -ne 0 ]; then
        break
    fi
    case $acao in
        "üîó Registrar URL")
            if ! verificar_caso_fechado; then
                abrir_url
            fi
            ;;
        "üì∏ Capturar √Årea da Tela")
            if ! verificar_caso_fechado; then
                capturar_area
            fi
            ;;
        "üé• Gravar Tela")
            if ! verificar_caso_fechado; then
                gravar_tela
            fi
            ;;
        "üìÇ Abrir Pasta de Trabalho")
            if ! verificar_caso_fechado; then
                xdg-open "$pasta"
            fi
            ;;
        "üìÑ Criar Relat√≥rio em PDF")
            if ! verificar_caso_fechado; then
                relatorio_final
            fi
            ;;    
        "üìà Monitorar Requisi√ß√µes")
            if ! verificar_caso_fechado; then
                monitorar_requests
            fi
            ;;
        "üîí Fechar Sess√£o")
            closedsession
            ;;
        "üö™ Sair")
            break
            ;;
        *)
            zenity --error --text="Op√ß√£o inv√°lida. Tente novamente."
            ;;
    esac
done
